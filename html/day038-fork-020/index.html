<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pic-Spot v2 (Day 038)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/dexie@3.2.4/dist/dexie.js"></script>
    <style>
        /* Custom scrollbar if needed, similar to the original app */
        body {
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
    </style>
</head>

<body class="bg-slate-950 text-slate-200 min-h-screen">
    <main id="drop-zone" class="min-h-screen p-8 transition-colors duration-300 relative">
        <div class="max-w-6xl mx-auto relative z-10">
            <header class="mb-12 text-center">
                <h1
                    class="text-4xl font-bold bg-gradient-to-r from-indigo-400 to-purple-400 bg-clip-text text-transparent mb-4 inline-block">
                    Pic-Spot
                </h1>
                <p class="text-slate-400">外部サイトから画像をドラッグ＆ドロップしてコレクション</p>
                <div class="mt-4 text-xs text-slate-600">HTML Version</div>
            </header>

            <div id="tabs-scroll-container" class="flex items-center gap-2 mb-8 overflow-x-auto pb-2">
                <div id="tabs-container" class="flex gap-2">
                    <!-- Tabs -->
                </div>
                <!-- Add Category Button -->
                <button id="add-tab-btn"
                    class="flex-shrink-0 flex items-center gap-1.5 px-4 py-2 rounded-full border border-dashed border-slate-700 text-slate-500 hover:text-indigo-400 hover:border-indigo-500 hover:bg-indigo-900/10 transition-all text-sm font-medium">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                    New
                </button>
                <!-- Import Button -->
                <button id="import-json-btn"
                    class="flex-shrink-0 flex items-center gap-1.5 px-4 py-2 rounded-full border border-slate-700 text-slate-500 hover:text-blue-400 hover:border-blue-900 hover:bg-blue-900/10 transition-all text-sm font-medium mr-2"
                    title="Import from JSON">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                        <polyline points="7 8 12 3 17 8" />
                        <line x1="12" y1="3" x2="12" y2="15" />
                    </svg>
                    Import
                </button>
                <input type="file" id="import-file" accept=".json" class="hidden">
                <!-- Export Button -->
                <button id="export-json-btn"
                    class="flex-shrink-0 flex items-center gap-1.5 px-4 py-2 rounded-full border border-slate-700 text-slate-500 hover:text-emerald-400 hover:border-emerald-900 hover:bg-emerald-900/10 transition-all text-sm font-medium mr-2"
                    title="Export as JSON">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                        <polyline points="7 10 12 15 17 10" />
                        <line x1="12" y1="15" x2="12" y2="3" />
                    </svg>
                    Export JSON
                </button>
                <!-- Clear Category Button -->
                <button id="clear-category-btn"
                    class="flex-shrink-0 flex items-center gap-1.5 px-4 py-2 rounded-full border border-slate-800 text-slate-500 hover:text-red-400 hover:border-red-900 hover:bg-red-900/10 transition-all text-sm font-medium"
                    title="Delete all images in this category">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 6h18" />
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
                    </svg>
                    Clean
                </button>
            </div>

            <!-- Gallery Grid -->
            <div id="gallery-grid" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
                <!-- Items will be injected here -->
            </div>

            <!-- Empty State -->
            <div id="empty-state"
                class="hidden col-span-full py-32 text-center border-2 border-dashed border-slate-800 rounded-3xl mt-8">
                <p class="text-slate-500">ここに画像をドロップしてください</p>
            </div>
        </div>

        <!-- Drag Overlay -->
        <div id="drag-overlay"
            class="absolute inset-0 bg-indigo-900/20 pointer-events-none opacity-0 transition-opacity duration-300 z-0">
        </div>
    </main>

    <!-- Lightbox Modal -->
    <div id="lightbox"
        class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-black/95 backdrop-blur-md hidden animate-in fade-in duration-300">
        <!-- Controls -->
        <div
            class="absolute top-6 flex items-center gap-4 px-6 py-3 bg-slate-900/80 backdrop-blur-xl rounded-full border border-slate-800 z-[60] shadow-2xl">
            <button id="zoom-out" class="text-slate-400 hover:text-indigo-400 p-1 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8" />
                    <line x1="21" y1="21" x2="16.65" y2="16.65" />
                    <line x1="8" y1="11" x2="14" y2="11" />
                </svg>
            </button>
            <span id="zoom-level" class="text-sm font-mono min-w-[50px] text-center text-slate-200">100%</span>
            <button id="zoom-in" class="text-slate-400 hover:text-indigo-400 p-1 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8" />
                    <line x1="21" y1="21" x2="16.65" y2="16.65" />
                    <line x1="11" y1="8" x2="11" y2="14" />
                    <line x1="8" y1="11" x2="14" y2="11" />
                </svg>
            </button>
            <div class="w-px h-4 bg-slate-700 mx-2"></div>
            <button id="zoom-reset"
                class="text-xs font-bold text-slate-400 hover:text-white transition-colors">RESET</button>
            <button id="copy-btn"
                class="px-3 py-1.5 flex items-center gap-2 text-slate-400 hover:text-indigo-400 transition-colors bg-slate-800/50 rounded-lg hover:bg-slate-800"
                title="クリップボードにコピー">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2" />
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" />
                </svg>
                <span class="text-xs font-bold uppercase tracking-wider">Copy</span>
            </button>
            <div class="w-px h-4 bg-slate-700 mx-2"></div>
            <button id="close-lightbox" class="text-slate-400 hover:text-red-400 transition-colors p-1" title="閉じる">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>

        <!-- Image Area -->
        <div id="lightbox-content"
            class="w-full h-full overflow-auto flex items-center justify-center p-12 cursor-grab active:cursor-grabbing">
            <div id="lightbox-image-container"
                class="relative transition-transform duration-200 ease-out origin-center">
                <img id="lightbox-img" src="" alt="Expanded"
                    class="max-w-full max-h-[85vh] rounded-lg shadow-2xl select-none pointer-events-none" />
            </div>
        </div>

        <p class="absolute bottom-6 text-slate-500 text-xs font-medium">スクロールでズーム / ダブルクリックでリセット</p>
    </div>

    <!-- Toast Notification -->
    <div id="toast"
        class="fixed bottom-8 left-1/2 transform -translate-x-1/2 bg-slate-800 text-white px-6 py-3 rounded-full shadow-2xl flex items-center gap-3 transition-all duration-300 opacity-0 translate-y-4 pointer-events-none z-[70]">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" class="text-emerald-400">
            <polyline points="20 6 9 17 4 12" />
        </svg>
        <span id="toast-message" class="font-medium text-sm">Message</span>
    </div>

    <!-- Custom Modal -->
    <div id="modal-overlay"
        class="fixed inset-0 bg-black/80 backdrop-blur-sm z-[80] hidden flex items-center justify-center opacity-0 transition-opacity duration-200">
        <div id="modal-content"
            class="bg-slate-900 border border-slate-700 p-6 rounded-2xl shadow-2xl max-w-sm w-full mx-4 transform scale-95 transition-transform duration-200">
            <h3 id="modal-title" class="text-xl font-bold text-white mb-2">Title</h3>
            <p id="modal-message" class="text-slate-400 mb-6 text-sm leading-relaxed">Message content goes here.</p>
            <div class="flex justify-end gap-3">
                <button id="modal-cancel"
                    class="px-4 py-2 rounded-lg text-slate-400 hover:text-white hover:bg-slate-800 transition-colors text-sm font-medium hidden">キャンセル</button>
                <button id="modal-confirm"
                    class="px-4 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-500 text-white shadow-lg shadow-indigo-500/20 transition-all text-sm font-medium">OK</button>
            </div>
        </div>
    </div>

    <!-- <script src="script.js"></script> -->
    <script>
        // Initialize Dexie
        const db = new Dexie('PicSpotDB');
        db.version(1).stores({
            images: '++id, timestamp'
        });
        // Add categories table and categoryId index in version 2
        db.version(2).stores({
            images: '++id, timestamp, categoryId',
            categories: '++id, name'
        });

        // State
        let isDragging = false;
        let activeImage = null;
        let activeImageIndex = -1;
        let galleryImages = [];
        let zoomScale = 1;
        let currentCategoryId = 0; // 0 for Unclassified

        // UI Elements & Helpers
        const toastEl = document.getElementById('toast');
        const toastMessageEl = document.getElementById('toast-message');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmBtn = document.getElementById('modal-confirm');
        const modalCancelBtn = document.getElementById('modal-cancel');
        const modalContent = document.getElementById('modal-content');

        // Helper: Show Toast
        function showToast(message, duration = 5000) {
            toastMessageEl.textContent = message;
            toastEl.classList.remove('opacity-0', 'translate-y-4', 'pointer-events-none');

            setTimeout(() => {
                toastEl.classList.add('opacity-0', 'translate-y-4', 'pointer-events-none');
            }, duration);
        }

        // Helper: Show Modal
        function showModal({ title, message, onConfirm, showCancel = false, inputPlaceholder = null }) {
            return new Promise((resolve) => {
                modalTitle.textContent = title;
                modalMessage.innerHTML = message; // Allow HTML for input

                let inputEl = null;

                if (inputPlaceholder !== null) {
                    // If input is requested, inject input field
                    const existingInput = document.getElementById('modal-input');
                    if (existingInput) existingInput.remove();

                    inputEl = document.createElement('input');
                    inputEl.id = 'modal-input';
                    inputEl.type = 'text';
                    inputEl.placeholder = inputPlaceholder;
                    inputEl.className = "w-full bg-slate-800 text-white px-4 py-2 rounded-lg border border-slate-700 focus:border-indigo-500 outline-none mb-4";
                    modalMessage.after(inputEl);
                    setTimeout(() => inputEl.focus(), 100);
                } else {
                    const existingInput = document.getElementById('modal-input');
                    if (existingInput) existingInput.remove();
                }

                if (showCancel) {
                    modalCancelBtn.classList.remove('hidden');
                    modalCancelBtn.onclick = () => {
                        closeModal();
                        resolve(false);
                    };
                } else {
                    modalCancelBtn.classList.add('hidden');
                }

                modalConfirmBtn.onclick = () => {
                    const value = inputEl ? inputEl.value : true;
                    if (inputPlaceholder !== null && !value) return; // Prevent empty input if required

                    closeModal();
                    if (onConfirm) onConfirm(value);
                    resolve(value);
                };

                modalOverlay.classList.remove('hidden');
                // Trigger reflow for transition
                void modalOverlay.offsetWidth;
                modalOverlay.classList.remove('opacity-0');
                modalContent.classList.remove('scale-95');
            });
        }

        function closeModal() {
            modalOverlay.classList.add('opacity-0');
            modalContent.classList.add('scale-95');
            setTimeout(() => {
                modalOverlay.classList.add('hidden');
            }, 200);
        }


        // Elements
        const dropZone = document.getElementById('drop-zone');
        const dragOverlay = document.getElementById('drag-overlay');
        const galleryGrid = document.getElementById('gallery-grid');
        const emptyState = document.getElementById('empty-state');
        const lightbox = document.getElementById('lightbox');
        const lightboxImg = document.getElementById('lightbox-img');
        const lightboxContainer = document.getElementById('lightbox-image-container');
        const zoomLevelEl = document.getElementById('zoom-level');
        const tabsContainer = document.getElementById('tabs-container');
        const addTabBtn = document.getElementById('add-tab-btn');

        // Initialize Categories
        async function initCategories() {
            const defaultCat = await db.categories.get(0);
            if (!defaultCat) {
                await db.categories.add({ id: 0, name: '未分類' });
            }
            await renderTabs();
            await renderGallery();
        }

        // Render Tabs
        async function renderTabs() {
            const categories = await db.categories.toArray();
            tabsContainer.innerHTML = '';

            categories.forEach(cat => {
                const btn = document.createElement('button');
                const isActive = cat.id === currentCategoryId;
                btn.className = `flex items-center gap-2 px-4 py-2 rounded-full border text-sm font-medium whitespace-nowrap transition-all ${isActive
                        ? 'bg-indigo-600 border-indigo-500 text-white shadow-lg'
                        : 'bg-slate-900 border-slate-700 text-slate-400 hover:text-white hover:border-indigo-500'
                    }`;

                const span = document.createElement('span');
                span.textContent = cat.name;
                btn.appendChild(span);

                // Delete button for categories other than Unclassified
                if (cat.id !== 0) {
                    const delBtn = document.createElement('span');
                    delBtn.innerHTML = '&times;';
                    delBtn.className = "ml-1 text-slate-400 hover:text-red-400 cursor-pointer font-bold";
                    delBtn.title = "カテゴリーを削除";
                    delBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteCategory(cat.id);
                    };
                    btn.appendChild(delBtn);
                }

                btn.onclick = () => switchCategory(cat.id);
                tabsContainer.appendChild(btn);
            });
        }

        async function switchCategory(id) {
            currentCategoryId = id;
            await renderTabs();
            await renderGallery();
        }

        async function addCategory() {
            const name = await showModal({
                title: "新しいカテゴリー",
                message: "カテゴリー名を入力してください",
                showCancel: true,
                inputPlaceholder: "例: 旅行, メモ, アイデア..."
            });

            if (name && typeof name === 'string') {
                const id = await db.categories.add({ name });
                switchCategory(id);
                showToast(`カテゴリー「${name}」を作成しました`);
            }
        }

        async function deleteCategory(id) {
            const confirmed = await showModal({
                title: "カテゴリーの削除",
                message: "このカテゴリーと、含まれるすべての画像を削除しますか？<br>この操作は取り消せません。",
                showCancel: true
            });

            if (confirmed) {
                await db.transaction('rw', db.images, db.categories, async () => {
                    await db.images.where('categoryId').equals(id).delete();
                    await db.categories.delete(id);
                });
                switchCategory(0); // Switch back to default
                showToast("カテゴリーを削除しました");
            }
        }

        const clearCatBtn = document.getElementById('clear-category-btn');
        const exportBtn = document.getElementById('export-json-btn');

        async function deleteAllImagesInCurrentCategory() {
            // Get category name for confirmation message
            let catName = "未分類";
            if (currentCategoryId !== 0) {
                const cat = await db.categories.get(currentCategoryId);
                if (cat) catName = cat.name;
            }

            const confirmed = await showModal({
                title: "画像をすべて削除",
                message: `「${catName}」内のすべての画像を削除しますか？<br>この操作は取り消せません。`,
                showCancel: true
            });

            if (confirmed) {
                await db.transaction('rw', db.images, async () => {
                    if (currentCategoryId === 0) {
                        const allImages = await db.images.toArray();
                        const idsToDelete = allImages
                            .filter(img => img.categoryId === 0 || img.categoryId === undefined)
                            .map(img => img.id);
                        await db.images.bulkDelete(idsToDelete);
                    } else {
                        await db.images.where('categoryId').equals(currentCategoryId).delete();
                    }
                });
                renderGallery();
                showToast("画像をすべて削除しました");
            }
        }

        async function exportToJSON() {
            const confirmed = await showModal({
                title: "JSONエクスポート",
                message: "すべてのカテゴリーと画像をJSONファイルとして書き出します。<br>画像が多い場合、処理に時間がかかることがあります。",
                showCancel: true
            });

            if (!confirmed) return;

            try {
                const categories = await db.categories.toArray();
                const images = await db.images.toArray();

                const outputImages = [];

                // Helper to convert Blob to Base64
                const blobToBase64 = (blob) => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                };

                // Convert all images
                for (const img of images) {
                    const base64 = await blobToBase64(img.blob);
                    outputImages.push({
                        id: img.id,
                        name: img.name,
                        type: img.type,
                        timestamp: img.timestamp,
                        categoryId: img.categoryId || 0,
                        data: base64
                    });
                }

                const exportData = {
                    version: "pic-spot-v2-export",
                    exportedAt: new Date().toISOString(),
                    categories: categories,
                    images: outputImages
                };

                const jsonStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonStr], { type: "application/json" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `pic-spot-backup-${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast(`エクスポート完了！${images.length}枚の画像を保存しました`);

            } catch (error) {
                console.error("Export failed:", error);
                showModal({
                    title: "エラー",
                    message: "エクスポートに失敗しました。詳細はコンソールを確認してください。"
                });
            }
        }

        // Import JSON Logic
        const importBtn = document.getElementById('import-json-btn');
        const importFileInput = document.getElementById('import-file');

        importBtn.onclick = () => {
            importFileInput.click();
        };

        importFileInput.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const confirmed = await showModal({
                title: "JSONインポート",
                message: "JSONファイルからデータを読み込みますか？<br>既存のデータは保持されますが、同じデータを取り込むと重複する可能性があります。",
                showCancel: true
            });

            if (!confirmed) {
                importFileInput.value = '';
                return;
            }

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                if (!data.version || !data.categories || !data.images) {
                    throw new Error("Invalid JSON format");
                }

                // Helper: Convert Base64 to Blob
                const base64ToBlob = async (base64) => {
                    const res = await fetch(base64);
                    return await res.blob();
                };

                // 1. Import Categories & Create Map (OldID -> NewID)
                const categoryMap = new Map();
                categoryMap.set(0, 0); // Unclassified maps to itself

                const existingCategories = await db.categories.toArray();

                for (const cat of data.categories) {
                    if (cat.id === 0) continue; // Unclassified always exists

                    // Check if category with same name exists
                    const existing = existingCategories.find(c => c.name === cat.name);
                    if (existing) {
                        categoryMap.set(cat.id, existing.id);
                    } else {
                        const newId = await db.categories.add({ name: cat.name });
                        categoryMap.set(cat.id, newId);
                    }
                }

                // 2. Import Images
                let count = 0;
                for (const img of data.images) {
                    const blob = await base64ToBlob(img.data);
                    const newCategoryId = categoryMap.get(img.categoryId) || 0; // Default to 0 if map fails

                    await db.images.add({
                        blob: blob,
                        name: img.name,
                        type: img.type,
                        timestamp: img.timestamp, // Keep original timestamp? Or new? Let's keep original for history.
                        categoryId: newCategoryId
                    });
                    count++;
                }

                importFileInput.value = '';
                await renderTabs();
                await renderGallery();
                showToast(`インポート成功！${count}枚の画像を追加しました`);

            } catch (error) {
                console.error("Import failed:", error);
                showModal({
                    title: "エラー",
                    message: "インポートに失敗しました。正しいPic-Spot形式のJSONファイルか確認してください。"
                });
                importFileInput.value = '';
            }
        };

        addTabBtn.onclick = addCategory;
        clearCatBtn.onclick = deleteAllImagesInCurrentCategory;
        exportBtn.onclick = exportToJSON;

        // Render Images
        async function renderGallery() {
            let images;
            if (currentCategoryId === 0) {
                const allImages = await db.images.orderBy('timestamp').reverse().toArray();
                images = allImages.filter(img => img.categoryId === 0 || img.categoryId === undefined);
            } else {
                images = await db.images.where('categoryId').equals(currentCategoryId).reverse().sortBy('timestamp');
            }

            galleryImages = images;

            galleryGrid.innerHTML = '';

            if (images.length === 0) {
                galleryGrid.classList.add('hidden');
                emptyState.classList.remove('hidden');
            } else {
                galleryGrid.classList.remove('hidden');
                emptyState.classList.add('hidden');

                images.forEach((img, index) => {
                    const blobUrl = URL.createObjectURL(img.blob);

                    const card = document.createElement('div');
                    card.className = "group relative aspect-square rounded-2xl overflow-hidden bg-slate-900 border border-slate-800 hover:border-indigo-500 transition-all cursor-pointer shadow-xl";
                    card.onclick = () => openLightbox(index);

                    const imageEl = document.createElement('img');
                    imageEl.src = blobUrl;
                    imageEl.alt = img.name;
                    imageEl.className = "w-full h-full object-cover transition-transform duration-500 group-hover:scale-110";

                    const overlay = document.createElement('div');
                    overlay.className = "absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity";

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = "absolute top-3 right-3 p-2 bg-red-500/80 hover:bg-red-500 rounded-full opacity-0 group-hover:opacity-100 transition-all transform translate-y-2 group-hover:translate-y-0";
                    deleteBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteImage(img.id);
                    };

                    card.appendChild(imageEl);
                    card.appendChild(overlay);
                    card.appendChild(deleteBtn);
                    galleryGrid.appendChild(card);
                });
            }
        }

        async function deleteImage(id) {
            if (await showModal({
                title: "画像の削除",
                message: "この画像を削除しますか？",
                showCancel: true
            })) {
                await db.images.delete(id);
                renderGallery();
                showToast("画像を削除しました");
            }
        }

        async function start() {
            await initCategories();
        }

        start();

        // Drag and Drop Logic
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            isDragging = true;
            dragOverlay.classList.remove('opacity-0');
            dropZone.classList.add('bg-indigo-900/20');
        });

        dropZone.addEventListener('dragleave', (e) => {
            if (e.relatedTarget === null || !dropZone.contains(e.relatedTarget)) {
                isDragging = false;
                dragOverlay.classList.add('opacity-0');
                dropZone.classList.remove('bg-indigo-900/20');
            }
        });

        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            isDragging = false;
            dragOverlay.classList.add('opacity-0');
            dropZone.classList.remove('bg-indigo-900/20');

            const items = Array.from(e.dataTransfer.items);
            let addedCount = 0;

            for (const item of items) {
                if (item.kind === 'file') {
                    const file = item.getAsFile();
                    if (file && file.type.startsWith('image/')) {
                        await db.images.add({
                            blob: file,
                            name: file.name,
                            type: file.type,
                            timestamp: Date.now(),
                            categoryId: currentCategoryId
                        });
                        addedCount++;
                    }
                }
                else if (item.kind === 'string' && item.type === 'text/html') {
                    item.getAsString(async (html) => {
                        const doc = new DOMParser().parseFromString(html, 'text/html');
                        const img = doc.querySelector('img');
                        if (img?.src) {
                            await fetchAndSaveImage(img.src, img.alt || 'web-image');
                        }
                    });
                }
            }
            renderGallery();
            if (addedCount > 0) showToast(`${addedCount}枚の画像を追加しました`);
        });

        const fetchAndSaveImage = async (url, name) => {
            try {
                const response = await fetch(url);
                const blob = await response.blob();
                await db.images.add({
                    blob,
                    name: name || 'dropped-image',
                    type: blob.type,
                    timestamp: Date.now(),
                    categoryId: currentCategoryId
                });
                renderGallery();
                showToast("Web上の画像を保存しました");
            } catch (error) {
                console.error('Failed to fetch image:', error);
                showModal({
                    title: "エラー",
                    message: "一部の画像はセキュリティ制限(CORS)により直接保存できませんでした。"
                });
            }
        };

        // Paste Logic
        window.addEventListener('paste', async (e) => {
            e.preventDefault();
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            let pasted = false;

            for (const item of items) {
                if (item.kind === 'file' && item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    if (file) {
                        await db.images.add({
                            blob: file,
                            name: `pasted-image-${Date.now()}`,
                            type: file.type,
                            timestamp: Date.now(),
                            categoryId: currentCategoryId
                        });
                        renderGallery();
                        pasted = true;
                    }
                }
            }
            if (pasted) showToast("画像を貼り付けました");
        });


        // Lightbox Logic
        function openLightbox(index) {
            if (index < 0 || index >= galleryImages.length) return;

            activeImageIndex = index;
            const img = galleryImages[index];
            activeImage = img;

            zoomScale = 1;
            updateZoom();
            lightboxImg.src = URL.createObjectURL(img.blob);
            lightbox.classList.remove('hidden');
        }

        function closeLightbox() {
            lightbox.classList.add('hidden');
            activeImage = null;
            activeImageIndex = -1;
            lightboxImg.src = '';
        }

        function updateZoom() {
            lightboxContainer.style.transform = `scale(${zoomScale})`;
            zoomLevelEl.textContent = `${Math.round(zoomScale * 100)}%`;
        }

        function showNextImage() {
            if (activeImageIndex === -1) return;
            const nextIndex = (activeImageIndex + 1) % galleryImages.length;
            openLightbox(nextIndex);
        }

        function showPrevImage() {
            if (activeImageIndex === -1) return;
            const prevIndex = (activeImageIndex - 1 + galleryImages.length) % galleryImages.length;
            openLightbox(prevIndex);
        }

        // Keyboard Navigation
        document.addEventListener('keydown', (e) => {
            if (lightbox.classList.contains('hidden')) return;

            switch (e.key) {
                case 'ArrowRight':
                    showNextImage();
                    break;
                case 'ArrowLeft':
                    showPrevImage();
                    break;
                case 'Escape':
                    closeLightbox();
                    break;
            }
        });

        // Lightbox Controls
        document.getElementById('close-lightbox').onclick = closeLightbox;
        document.getElementById('zoom-in').onclick = () => {
            zoomScale = Math.min(zoomScale + 0.2, 5);
            updateZoom();
        };
        document.getElementById('zoom-out').onclick = () => {
            zoomScale = Math.max(zoomScale - 0.2, 0.5);
            updateZoom();
        };
        document.getElementById('zoom-reset').onclick = () => {
            zoomScale = 1;
            updateZoom();
        };

        document.getElementById('lightbox-content').onclick = (e) => {
            if (e.target === document.getElementById('lightbox-content') || e.target === lightboxContainer) {
                closeLightbox();
            }
        };

        lightbox.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY < 0) {
                zoomScale = Math.min(zoomScale + 0.1, 5);
            } else {
                zoomScale = Math.max(zoomScale - 0.1, 0.5);
            }
            updateZoom();
        });

        lightboxContainer.addEventListener('dblclick', () => {
            zoomScale = zoomScale === 1 ? 2 : 1;
            updateZoom();
        });

        // Clipboard Copy
        document.getElementById('copy-btn').onclick = async () => {
            if (!activeImage) return;

            try {
                const url = URL.createObjectURL(activeImage.blob);
                const img = new Image();

                const pngBlob = await new Promise((resolve, reject) => {
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        canvas.toBlob((blob) => {
                            if (blob) resolve(blob);
                            else reject('Conversion failed');
                        }, 'image/png');
                    };
                    img.onerror = reject;
                    img.src = url;
                    // Handle cross origin if needed (though blobs are usually fine)
                });

                const item = new ClipboardItem({ 'image/png': pngBlob });
                await navigator.clipboard.write([item]);

                URL.revokeObjectURL(url);

                // Show Toast instead of alert
                showToast("クリップボードにコピーしました", 5000);

            } catch (error) {
                console.error("クリップボードにコピーできませんでした", error);
                showModal({
                    title: "エラー",
                    message: "コピーに失敗しました。このブラウザが画像コピーをサポートしていない可能性があります。"
                });
            }
        };

    </script>
</body>

</html>