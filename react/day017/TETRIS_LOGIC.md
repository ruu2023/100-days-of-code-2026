# Reactテトリス ロジック完全解説

このドキュメントでは、今回実装したテトリスの内部ロジックについて解説します。

## 🏗 全体のアーキテクチャ

このアプリは、**カスタムフック**を活用してゲームのロジック（計算）とビュー（Reactコンポーネント）を分離しています。

### データの流れ
1.  **Hooksが計算**: プレイヤーの位置、盤面の状態、スコアなどを計算。
2.  **State更新**: 計算結果をReactのStateに保存。
3.  **レンダリング**: Stateが変わるとコンポーネントが再描画され、画面が更新される。

## 🧩 主要なモジュール解説

### 1. `usePlayer.ts` (プレイヤー管理)
操作中のブロック（テトリミノ）だけの情報を管理します。

*   **保持データ**:
    *   `pos`: 現在の座標 `{x, y}`
    *   `tetromino`: ブロックの形状データ（2次元配列）
    *   `collided`: 何かにぶつかって固定される直前かどうか
*   **回転ロジック**:
    テトリミノは2次元配列なので、数学的な「行列の回転」を行います。
    1.  **転置**: 全ての `[y][x]` を `[x][y]` に入れ替える。
    2.  **反転**: 各行の配列を逆順にする。
    これで90度回転が実現できます。

### 2. `useStage.ts` (盤面管理) ★最重要
ここが今回の修正で肝となった部分です。

*   **`grid` (裏側のデータ)**: すでに積み重なって固定されたブロックだけの情報。
*   **`stage` (表示用データ)**: `grid` に、現在操作中の `player` を合成して作った、画面表示用の完全な情報。

**なぜ分けたのか？**
以前はこれらを混ぜて1つの変数で管理していましたが、それだと「ブロックを動かすたびに盤面全体を書き換える」必要があり、バグの温床になっていました。
分けることで、「操作中は `player` だけ更新し、レンダリング時に `grid` の上に `player` を重ねて表示する」という効率的な処理になりました。

### 3. `gameHelpers.ts` / `checkCollision` (衝突判定)
「次に移動しようとしている場所」が安全かどうかを調べる関数です。

ループ処理でブロックの全セルをチェックします：
1.  **枠外チェック**: 盤面の外に出ようとしていないか？
2.  **他のブロックチェック**: 移動先に、すでに固定されたブロック（`grid` 内のブロック）がないか？

もしどちらかがNGなら「衝突」と判断し、移動をキャンセルしたり、ブロックをその場に固定したりします。

### 4. `useInterval.ts` (ゲームループ)
JavaScript標準の `setInterval` はReactと相性が悪いため、カスタムフック化しています。
これが「1秒ごとに `drop()` 関数を呼ぶ」という心臓部の役割を果たしています。この間隔（`dropTime`）を短くすることで、レベルアップ時のスピードアップを実現しています。

## 🔄 ゲームの1サイクルの流れ

1.  **自動落下**: `useInterval` が一定時間ごとに `drop` 関数を呼ぶ。
2.  **移動判定**: `player` のY座標を+1しようとする。
3.  **衝突チェック**:
    *   **衝突しない**: そのまま位置更新。画面再描画。
    *   **衝突する**:
        1.  現在の位置でブロックを `grid` に焼き付ける（固定）。
        2.  行が揃っていれば削除（`sweepRows`）。
        3.  新しいブロックを上から出現させる。
        4.  判定：もし新しいブロックがいきなり衝突したら **Game Over**。

---
このロジック構成であれば、Reactの「宣言的なUI」という強みを活かしつつ、パズルゲームとして成立させることができます。
