[
  {
    "id": "hatebu-it-6-06b4a0865acb",
    "title": "Gemini × NotebookLM 連携で「自分専用エージェント」を量産する：蓄積した履歴を血肉化する究極の活用術",
    "url": "https://zenn.dev/minipoisson/articles/2806b4a0865acb",
    "source": "Hatena:it",
    "bookmarkCount": 289,
    "summary": "【冒頭】\n1. 【課題】「ただの検索」から「文脈を理解した対話」へ\n前回はデータの準備をしましたが、今回はそのデータを**4人の専門家（エージェント）**として動かし、毎日使えるレベルまで効率化します。\n過去の記事で、 Gemini の全履歴を NotebookLM に集約し、検索・分析ができる環境を構築した話を載せました。\n\n確かに NotebookLM 上での検索は強力です。ですが、チャットの度に、例えば記事の原稿にするためならば「〇〇の文体で書いて」と指示し、自己分析のためならば「過去の私の傾向からアドバイスして」と指示することになりますが、繰り返す使う目的の場合でも毎回資料と指示を指定する必要があり、手間が掛かってしまいます。また、 NotebookLM のノートブックでは 2025年後半からチャットの履歴を残すことも可能になりましたが、よく使うノートブックがあるとその履歴の中に様々な目的のチャットが入り混じってしまって後で読み返すのが難しくなってしまいます。\n2026年の1月から、 Gemini のチャットで NotebookLM のノートブックが資料として指定できる「NotebookLM 連携」機能が使えるようになりました。なので、 Gemini の全履歴を載せたノートブックを Gemini のチャット欄で資料として指定することにより活用の仕方が広がったことを追記しました。\n確かにこの機能を使うと、 NotebookLM のノートブックで様々な目的のチャットが入り混じることは無くなります。ですが、繰り返し使う特定の目的（Zenn執筆、自己分析など）であっても、依然チャットの度に指示をチャットで入力する必要がありますし、そのノートブックを資料として毎回指定する必要があります。これは例えるなら、 「図書館（NotebookLM）に毎回、司書（指示）を連れて行く」ような手間 でした。\nそこで、 蓄積した膨大な知識をベースに、特定の目的（Zenn執筆、自己分析など）に特化した「専属エージェント」をワンクリックで起動したいと考えました。\n\n 2. 【解決策】Gemini の新機能「Gems × NotebookLM 連携」\nGemini には、繰り返し使う特定の目的のための指示や資料を予め指定しておく Gems という機能があります（2024年8月より利用可能）。そこで今回は Gemini の Gems と NotebookLM 連携を組み合わせることを考えました。\n技術スタック:\n:::message この連携のキモ：役割と知識の分離\n\nNotebookLM: 過去のチャット履歴（Markdown化済み）を格納する「長期記憶」。\nCustom Gems: 特定の役割（システム指示）を与える「人格」。::: この2つがz合体することで、はじめて「自分を熟知した専門家」が誕生します。\n\n革新的なポイントは、2026年1月から利用可能になった、 Gemini で資料として NotebookLM のノートブックを直接指定できる機能の活用です。これにより、指示文（System Instruction）を短く保ちつつ、数百万トークン規模の背景知識をエージェントに持たせる\n\n【中盤】\nめるポジティブな姿勢。\n* 技術に対する深い洞察と誠実さを感じさせる態度。\n\n知識: Gemini の全履歴を載せたノートブックを指定します。\n\nなお、カスタム指示を上手く書くのが難しそうに思えるかもしれませんが、決してそんなことはありません。私の方で初めに書いたカスタム指示はもっと断片的なものでした。ですが、画面キャプチャの中で赤い丸を付けた部分は Gemini に Gem のカスタム指示を最適化させるボタンであり、そこを押すと Gemini が上の様なプロフェッショナルな指示文に書き換えてくれました。\nそして、「この記事の構成案も、実際に履歴から Gem が抽出したものです」\n\n 3.2. note.com 向け Gem\n\n名前: note.com 用の記事提案・作成支援\n\n説明: エッセイ的な記事の作成。技術を扱う場合は背景の思いや試行錯誤の物語を重視\nカスタム指示:\n\nあなたはコミュニティプラットフォーム note.com での発信をサポートする、熟練のライターです。資料（チャット履歴）にある議論や開発の記録を、価値ある記事へと昇華させるお手伝いをします。\n\nPurpose and Goals:\n* 資料（チャット履歴）から、社会や生活に関する様々な事柄や議論や課題、そして課題解決に用いた技術的手段を抽出すること。\n* 専門用語を噛み砕き、専門家ではない人にも伝わるような、親しみやすく魅力的な文章を提案すること。\n* 技術的な内容については、開発の動機、葛藤、喜びといった'知的ライフログ'としてのストーリー性を引き出すこと。\n\nBehaviors and Rules:\n1) Analysis and Extraction:\n- 提供されたチャット履歴を詳細に分析し、記事の核となる主要なトピックや議論のポイントを3〜5つ特定してください。\n- 単なる事実の羅列ではなく、読者の興味を引く'切り口'（フック）を見つけてください。\n2) Article Structure and Drafting:\n- 読者の興味を惹きつけるタイトル案を3つ提案してください。\n- 構成案（目次）を作成し、それぞれのセクションで書くべき内容の要点をまとめてください。\n- 専門用語が出てきた場合は、比喩や身近な例えを用いて分かりやすく説明してください。\n3) Narrative Enhancement:\n- 開発秘話や個人の想いに焦点を当てた、共感を得やすいエピソードを強調してくださ\n\n【結論付近】\nていきます。\n\n 5. 【まとめ】AI は「ツール」から「共生するパートナー」へ\n前回記事では、 Gemini チャットで蓄積されたデータを Google Takeout で取り出し、 Python のコードにより Markdown 形式に変換して NotebookLM のノートブックに読み込めるようにし、そのノートブックのチャット欄で利用していました。今回、この仕組みを再構成し、データの蓄積と活用を NotebookLM と Gemini に分離し、更に Gemini での活用の中でも頻用するものを Gems に分離しました。今回このような Gem を作成したことにより、 AI をより良く活用する上で大切なのは蓄積する 「データの量」 のみではなく、それにも増して 蓄積されたデータを上手に活用するための仕組み の方も大切であるということがよく分かりました。\n今回作成したのは Gem 4つですが、他にも、指定するプロンプトや知識ベースを工夫するなどして、ライフログとして活用するための Gem や分野別に特化した Gem 等を作って試してみたいです。特に、 Gem の知識としては資料を複数指定することができ、 NotebookLM のノートブックを複数指定することも可能であり、この部分の工夫次第で様々な活用の仕方ができるはずですので、上手い活用の仕方を見つけていきたいと考えています。",
    "category": "AI"
  },
  {
    "id": "hatebu-it-0-s/20260210a/",
    "title": "ログ設計ガイドラインを公開しました | フューチャー技術ブログ",
    "url": "https://future-architect.github.io/articles/20260210a/",
    "source": "Hatena:it",
    "bookmarkCount": 254,
    "summary": "はじめにTechnology Innovation Groupの八木です。\nフューチャー社内の有志メンバーでログ設計ガイドラインを作成し公開しました！\nログは、システムの稼働状況を可視化し、トラブルが発生した際に迅速に原因特定するための生命線になります。しかし、その重要性の一方で、プロジェクトごとに設計がバラバラになりがちだったり、とりあえず標準出力しているだけになっていたりと、十分に活用しきれていないケースも多く見受けられます。\n本記事では、今回公開したログ設計ガイドラインの背景や、現場で役立つ設計のポイントを抜粋してご紹介します。\nガイドライン作成のモチベーションこれまで、ログ設計は個々のエンジニアの経験則や、プロジェクトごとの慣習に委ねられることが多くありました。しかし、システムが複雑化し、マイクロサービスやクラウドネイティブな構成が当たり前になった現代において、ログの役割は「単なるデバッグ用のテキスト」から「オブザーバビリティ（可観測性）の基盤」へと進化しています。\nログ設計が不十分だと、以下のような課題が発生し得ます。\n\n原因追求ができない: 必要な情報（トレースIDやユーザーIDなど）が不足しており、エラーの原因を追えない\n横断的な集計ができない: フォーマットがバラバラで、CloudWatch Logs や Datadog などのツールで検索・集計がしにくい\nコストと性能: 無意味なログが大量に出力され、ストレージ費用を圧迫したり、アプリケーションの性能を劣化させる\n\nガイドラインのポイント紹介ログ設計ガイドラインでは、アプリケーションログを対象に命名規則から出力項目、セキュリティ、コストまで幅広くカバーしています。その中から主なトピックをいくつかピックアップします。\n1. ログキー命名規則特定のプラットフォーム（AWS/GCP）やSaaS（Datadog/New Relic）に依存しすぎない移植性の高いログにするため、標準仕様といえるOpenTelemetry (OTel) Semantic ConventionsやElastic Common Schema (ECS)をベースにした命名規則を推奨しています。\n\n標準化のメリット: timestamp や @timestamp といった些細な表記揺れを排除し、ログ解析ツールで利用しやすくする\n共通スキーマ: timestamp, severity.text, message, trace_id といった、どのログにも含めるべき必須項目を定義する\n\n2. コンテキスト情報の付与エラーが発生した際、「何が起きたか（メッセージ）」だけでは原因特定に至らないことが多々あります。「どのユーザーが」「どのリクエストで」起こしたのかというコンテキスト情報を付与することで、調査の解像度を高めます。\n\nトレースID：マイクロサービスなどの分散システムにおいて、サービス間をまたぐ一連の処理を紐付けるためのIDです。これを全ログに含めることで、点在するログを追跡可能にします\nHTTP/DBコンテキスト：リクエストメソッドやパス、ステータスコード、DBクエリの実行時間といった情報を「拡張スキーマ」として定義します。これにより、「特定のAPIだけレスポンスが遅い」「特定のクエリでエラーが頻発している」といった多角的な分析が可能になります\n\n3. 出力ルールとメッセージの書き方意外と疎かにされがちなログメッセージ自体の書き方について紹介しています。\n\n事実とデータの分離: メッセージ内に可変値を入れる（例. User login failed: {userId}） ではなく、メッセージ自体は User login failed と固定し、user.id を構造化データの別フィールドとして分離します。これにより、ログの集計が楽になります\nメッセージコードの導入: エラーログを運用者が参照する「運用手順書（障害対応マニュアル）」と紐づけるために、一意のメッセージコード（例：E001）を付与するパターンを紹介しています\n「通知フラグ」の考え方: 全てのエラーを即座に通報するのではなく、ログに「通知の是非」のフラグを持たせる設計についても言及しています\n\n4. セキュリティと機密情報ログに含めてはいけない情報（個人情報、パスワード、認証トークン等）の管理と、誤って出力しないためのマスキングの考え方についてもガイドを設けています。\nガイドライン活動後の感想私自身、これまでログ設計についてあまり時間をかける機会がありませんでした。しかし、今回のガイドライン活動を通して、今まで慣習として従っていたキー名や構造にもOTel Semantic Conventionsといった標準が存在することや、効率的に開発/運用するための考え方を知ることができました。\n加えて、活動内でシニアな方々と議論することで、なぜそのような設計なのかというWhyの部分も学ぶことができたことも大きな収穫でした。\n今後は自らのプロジェクトでこれを実践し、開発/運用者が幸せになれるシステム作りに貢献したいと思います。\nおわりにログは「出力して終わり」ではなく、「トラブル時にいかに迅速に原因を特定できるか」という運用のための資産になります。\n今回公開したガイドラインが、皆さんのプロジェクトにおける保守・運用しやすいシステム作りの一助となれば幸いです。\nまた、ガイドラインを読んでのフィードバックやGitHubでのIssue/PRもお待ちしております！\nログ設計ガイドライン:\n\nhttps://future-architect.github.io/arch-guidelines/documents/forLog/log_guidelines.html",
    "category": "Security"
  }
]